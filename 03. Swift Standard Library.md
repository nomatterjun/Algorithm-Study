
## Array (배열)

배열은 정렬된 값들을 묶는 가장 대표적인 컬렉션입니다.

``` Swift
let people = ["Brian", "Stanley", "Ringo"]
```

배열의 세 가지 프로토콜을 채택하고 있습니다.

- `Sequence`

배열 안을 최소 한 번 반복할 수 있습니다.

- `Collection`

여러 번 탐색될 수 있고, 사라지지 않습니다. 또한 `subscript` 연산자를 사용할 수 있습니다.

- `RandomAccessCollection`

효율적으로 접근할 수 있습니다.

#### Order

배열의 값들은 순서를 갖습니다. 위의 예시를 가져오면, "Brian"은 "Stanley"보다 앞에 있습니다.

이 순서는 0부터 시작하는 index에 사용됩니다.

``` Swift
people[0] // "Brian"
people[1] // "Stanley"
people[2] // "Ringo"
```

#### Random Access

배열의 값은 접근할 떄 Constant Time 복잡도를 가집니다.
예를 들어 `people[1]`을 사용하면 직접 곧바로 "Stanley"라는 값을 가져온다는 것이죠.

### Array Performance

값에 접근하는 것 뿐만 아니라, 배열의 값을 수정할 때의 퍼포먼스 또한 개발자에게는 중요한 요소 중 하나입니다.

그리고 이에 영향을 미치는 요소는 크게 두가지가 있습니다.

#### 추가 위치

배열에 값을 추가하는 가장 효율적인 방법은 배열의 끝에 값을 추가하는 것입니다.

``` Swift
people.append("Charles")
print(people) // ["Brian", "Stanley", "Ringo", "Charles"]
```

배열의 끝에 값을 추가하는 `append` 메서드는 Constant Time 복잡도를 갖는 아주 효율적인 메서드입니다.

하지만 배열의 중간에 값을 추가해야할 경우도 아주 허다하겠죠.

배열의 중간에 값이 들어오려면, 해당 공간을 우선 비워주어야합니다. 그 후에 다른 값들을 뒤로 미뤄주면서 값이 중간에 들어올 수 있게 되는 것이죠.

이 말은, 곧 배열의 맨 앞에 어떤 값을 추가하는 것은 상당히 비효율적인 작업이라는 뜻이기도 합니다.

``` Swift
people.insert("Andy", at: 0)
// ["Andy", "Brian", "Stanley", "Ringo", "Charles"]
```

위의 경우 배열의 가장 앞에 값을 추가했기 때문에, 배열의 크기만큼 연산이 필요합니다.
만약 이런 식의 연산이 많이 필요한 경우라면, 배열이 아니라 다른 형태의 데이터 구조를 사용하는 것이 좋습니다.

#### 수용력

내부적으로 Swift는 배열의 크기를 정해서 공간을 메모리에 할당해둡니다.
만약 배열의 크기가 내부적으로 정해진 이 공간보다 커지게 되면, 더 많은 공간을 확보하기 위해 이 배열을 다시 만들게 됩니다.
배열의 모든 값을 복사하여 새로운 더 커다란 배열로 만든다는 것은 꽤 큰 리소스를 사용하는 작업입니다.

이런 작업이 필요한 경우에는 배열의 가장 끝에 값을 추가하더라도 `O(n)`의 시간 복잡도를 갖게 될 수도 있다는 뜻이죠.
다행히도 Swift 언어는 이런 현상의 발생을 최소화하기 위한 여러 방책들을 구비해두었습니다.
대표적으로 배열의 용량이 꽉 차게 되면, 화끈하게 현재 용량의 두 배 만큼의 배열을 준비해두는 방법이 있습니다.

## Dictionary (딕셔너리)

딕셔너리는 **key-value**의 쌍으로 이루어진 컬렉션입니다.

``` Swift
var scores: [String: Int] = ["Eric": 9, "Mark": 12, "Wayne": 1]
```

딕셔너리에는 순서가 없습니다. 따라서 원하는 위치에 값을 추가하는 것 또한 불가능합니다.

또한 Key에 해당되는 값에는 `Hashable` 프로토콜을 채택한 값들만 올 수 있습니다. 다만 Swift의 거의 모든 값들이 `Hashable`하기 때문에 큰 걱정은 하지 않아도 됩니다.

``` Swift
scores["Andrew"] = 0
```

딕셔너리에 값을 추가하려면 Key값에 Value를 넣어주는 방식으로 진행됩니다.

여전히 `Collection` 프로토콜을 채택하고 있기 때문에 각각의 값들에 순서대로 접근하는 것은 가능하지만 그 순서는 보장되지 않습니다.

하지만 이런 방식으로 얻는 장점도 있습니다.

모든 연산이 Constant TIme의 시간복잡도를 가질 수 있게 되었기 때문이죠!

## Set (세트)

세트는 유일한 값을 갖는 컬렉션입니다. 이게 무슨 말이냐면..! 이미 갖고 있는 값은 세트에 추가되지 않습니다.

``` Swift
var bag: Set<String> = ["Candy", "Juice", "Gummy"]
bag.insert("Candy")
print(bag) // ["Candy", "Juice", "Gummy"]
```

세트는 보통 이러한 특성이 유용할 때를 제외하고는 잘 사용되지 않기는 합니다.
하지만 중요한 세가지 컬렉션 중 하나이기 때문에 알아두어야겠죠!

## Swift Collections Package

애플이 제공하는 패키지 중에 Swift Collections Package라는 것이 있습니다.
이 패키지는 커뮤니티에서 자주 사용되는 데이터 구조이지만 Swift 공식 버전에는 아직 들어오지 않은 데이터 구조들이 제공됩니다.

### Deque (덱)

`Deque`는 배열과 상당히 유사한 데이터 구조입니다.
하지만 배열이 끝에서의 값 추가/제거에만 최적화된 것과는 반대로 덱은 맨 앞에서의 추가/제거에도 최적화되어 있습니다.

덱은 맨 앞과 맨 뒤 모두 `O(1)`의 Constant Time 복잡도를 갖습니다.
이런 장점이 있는데 단점은 없다면 그냥 배열을 덱으로 대체해도 됐겠죠?
하지만 맨 앞의 값에 효율성을 가진 대신, 다른 모든 구역에서는 배열보다 낮은 효율성을 갖게 되었습니다.

배열과 덱 중에 어떤 데이터 구조를 사용할지는 개발자가 선택하면 되겠죠?

이 덱 외에도 Swift Collections Package에는 `OrderedDictionary`와 `OrderedSet`이라는 데이터 구조 또한 있습니다.
이 두 데이터 구조들은 이름 그대로 딕셔너리와 세트에 순서를 부여했지만, 마찬가지로 다른 성능에서는 손해를 보는 구조들입니다.
